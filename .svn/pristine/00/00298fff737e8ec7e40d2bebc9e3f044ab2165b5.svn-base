package com.ucf.customer.test;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;

import org.junit.Test;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;

import com.ucf.platform.framework.lock.LockHolder;

@ContextConfiguration(locations = { "classpath:/framework-lock-jedis-test.xml" })
public class UcfLockTest extends AbstractJUnit4SpringContextTests {

    private static String bizCode = "1000";

    private static String lockKey = "1234567890";

    private static long timeoutMsecs = 3000;

    private static long expireMsecs = 5000;

    private static long count = 0L;

    @Test
    public void testLock() {
        Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(new Runnable() {

            @Override
            public void run() {
                Lock lock = LockHolder.createLock(bizCode, lockKey, timeoutMsecs, expireMsecs);
                try {
                    lock.lock();
                    long c = System.currentTimeMillis() % 1000;
                    count += c;
                    Thread.sleep(c);
                    count -= c;
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
//                    if (count != 0)
                        System.out.println(count);
                }

            }
        }, 1, 10, TimeUnit.SECONDS);

        Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(new Runnable() {

            @Override
            public void run() {
                Lock lock = LockHolder.createLock(bizCode, lockKey, timeoutMsecs, expireMsecs);
                try {
                    lock.lock();
                    long c = System.currentTimeMillis() % 1000;
                    count += c;
                    Thread.sleep(c);
                    count -= c;
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
//                    if (count != 0)
                        System.out.println(count);
                }

            }
        }, 1, 10, TimeUnit.MILLISECONDS);
        while (true) {
        }

    }

    @Test
    public void testLockInterruptibly() {
        ThreadPoolExecutor consumeExecutor = new ThreadPoolExecutor(30, 30 + 10, 5, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(30 + 10), new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                Thread myThread = new Thread(r);
                myThread.setName("TT");
                return myThread;
            }
        }, new ThreadPoolExecutor.CallerRunsPolicy());

        while (true) {
            consumeExecutor.execute(new Runnable() {
                @Override
                public void run() {
                    Lock lock = LockHolder.createLock(bizCode, lockKey, timeoutMsecs, expireMsecs);
                    try {
                        lock.lockInterruptibly();
                        count++;
                        count--;
                    } catch (Throwable e) {
                        e.printStackTrace();
                    } finally {
                        lock.unlock();
//                        if (count != 0)
                            System.out.println(count);
                    }

                }
            });
        }
    }

    @Test
    public void testTryLock() {
        ThreadPoolExecutor consumeExecutor = new ThreadPoolExecutor(30, 30 + 10, 5, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(30 + 10), new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                Thread myThread = new Thread(r);
                myThread.setName("TT");
                return myThread;
            }
        }, new ThreadPoolExecutor.CallerRunsPolicy());

        while (true) {
            consumeExecutor.execute(new Runnable() {
                @Override
                public void run() {
                    Lock lock = LockHolder.createLock(bizCode, lockKey, timeoutMsecs, expireMsecs);
                    try {
                        if (lock.tryLock()) {
                            count++;
                            count--;
                        }
                    } catch (Throwable e) {
                        e.printStackTrace();
                    } finally {
                        lock.unlock();
//                        if (count != 0)
                            System.out.println(count);
                    }

                }
            });
        }
    }

    @Test
    public void testTryLockLongTimeUnit() {

        ThreadPoolExecutor consumeExecutor = new ThreadPoolExecutor(30, 30 + 10, 5, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(30 + 10), new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                Thread myThread = new Thread(r);
                myThread.setName("TT");
                return myThread;
            }
        }, new ThreadPoolExecutor.CallerRunsPolicy());

        while (true) {
            consumeExecutor.execute(new Runnable() {
                @Override
                public void run() {
                    Lock lock = LockHolder.createLock(bizCode, lockKey, timeoutMsecs, expireMsecs);
                    try {
                        if (lock.tryLock(1, TimeUnit.SECONDS)) {
                            count++;
                            count--;
                        }
                    } catch (Throwable e) {
                        e.printStackTrace();
                    } finally {
                        lock.unlock();
                        if (count != 0)
                            System.out.println(count);
                    }

                }
            });
        }

    }

    @Test
    public void testUnlock() {
        Lock lock = LockHolder.createLock(bizCode, lockKey, timeoutMsecs, expireMsecs);
        lock.unlock();
    }

}
