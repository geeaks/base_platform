package com.ucf.customer.mq;

import java.util.Map;
import java.util.concurrent.locks.Lock;

import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;

import com.alibaba.fastjson.JSON;
import com.ucf.customer.dao.UcfTradeLogDao;
import com.ucf.customer.dao.UcfUserDao;
import com.ucf.customer.pojo.UcfTradeLog;
import com.ucf.customer.pojo.UcfUser;
import com.ucf.onlinepay.framework.common.bean.Money;
import com.ucf.platform.framework.core.log.UcfLogger;
import com.ucf.platform.framework.core.log.UcfLoggerFactory;
import com.ucf.platform.framework.lock.LockHolder;
import com.ucf.platform.framework.mq.UcfReceiveMessage;
import com.ucf.platform.framework.mq.UcfTopicTagAssemble;
import com.ucf.platform.framework.mq.consumer.AbstractUcfMQSyncConsumerConcurrently;
import com.ucf.platform.framework.mq.enums.RocketMQTopicEnum;
import com.ucf.platform.framework.mq.enums.UcfMQConsumeStatus;

/**
 * 代扣统计
 * @author 张磊
 *
 */
public class DKStatisticsMQConsumerService extends AbstractUcfMQSyncConsumerConcurrently {

	private static final UcfLogger LOGGER = UcfLoggerFactory.getLogger(DKStatisticsMQConsumerService.class);

	

	@Autowired
	private UcfTradeLogDao tradeLogDao;

	@Autowired
	private UcfUserDao userdao;

	@Resource(name = "sharedTransactionTemplate")
	private TransactionTemplate transactionTemplate;

	@Override
	public UcfTopicTagAssemble getTopicAndTagExpress() {
		UcfTopicTagAssemble assemble = new UcfTopicTagAssemble();
		assemble.setTopic(RocketMQTopicEnum.ROCKETMQ_MEMBER_TRADE_DKLOG_TOPICANDTAG.getTopic());
		assemble.setTag(RocketMQTopicEnum.ROCKETMQ_MEMBER_TRADE_DKLOG_TOPICANDTAG.getTag());
		return assemble;
	}

	@SuppressWarnings("unchecked")
	@Override
	public UcfMQConsumeStatus doConsume(UcfReceiveMessage msg){
		Map<Object, Object> mqReturnMap = (Map<Object, Object>) msg.getBizValue();
		String userId = (String) mqReturnMap.get("userId");
		String orderId = (String)mqReturnMap.get("orderId");
		String amount = (String)mqReturnMap.get("amount");
		LOGGER.info("记录交易日志MQ接收参数:" + JSON.toJSONString(mqReturnMap));
		Lock lock = LockHolder.createLock("MEMBER_DK_STATISTICS", "DK_ORDERID_" + orderId,10*1000,30*1000);
		try {
			if (lock.tryLock() && !tradeLogDao.isExist(orderId)) {
				final UcfTradeLog tradeLog = new UcfTradeLog();
			 	Money money = new Money();
			 	money.setCent(Long.parseLong(amount));
			 	tradeLog.setAmount(money);
			 	tradeLog.setUserId(userId);
			 	tradeLog.setOrderId(orderId);		 		
			 	boolean commit = (Boolean) transactionTemplate.execute(new TransactionCallback<Object>() {
			 		public Object doInTransaction(final TransactionStatus status) {
			 			try {
			 				// 判断customer表是否存在记录
			 				tradeLogDao.insertUcfTradeLog(tradeLog);
			 				Money sum = tradeLogDao.queryUserSumAmount(tradeLog.getUserId());
			 				if(sum!=null){
			 					UcfUser user = userdao.getUcfUserByUserId(tradeLog.getUserId());
			 					user.setAmount(sum.getCent());
			 					userdao.updateUcfUser(user);
			 				}
			 			} catch (final Exception e) {
			 				status.setRollbackOnly();
			 				LOGGER.error("记录交易日志数据库异常", e);
			 				return false;
			 			}
			 			return true;
			 		}
			 	});
		 		if (!commit) {
		 			LOGGER.error("记录交易日志异常,数据：" + JSON.toJSONString(mqReturnMap));
		 		}
		    }
		 }catch(Exception e){
			 LOGGER.error("记录交易日志异常", e);
		 } finally {
		    lock.unlock();
		 }
		 return UcfMQConsumeStatus.SUCCESS;
	}
	
	@Override
	public void handleMQException(UcfReceiveMessage msg) {
	

	}

}
