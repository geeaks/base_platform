package com.ucf.customer.task;

import java.util.List;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Autowired;

import com.ucf.customer.dao.UcfCardDao;
import com.ucf.customer.dao.UcfUserDao;
import com.ucf.customer.dao.plugin.Page;
import com.ucf.customer.pojo.UcfUser;
import com.ucf.customer.service.UserService;
import com.ucf.customer.utils.enums.EnumRedisKey;
import com.ucf.platform.framework.core.log.UcfLogger;
import com.ucf.platform.framework.core.log.UcfLoggerFactory;
import com.ucf.platform.framework.redis.RedisKVManager;
import com.ucf.schedule.client.AbstractTaskService;
import com.ucf.schedule.client.ScheduleStatusEnum;
import com.ucf.schedule.client.UcfScheduleResponse;

/**
 * @Description: 自动刷新用户数据缓存
 * @ClassName: AutoRefreshUserCache
 * @author gaoxiang
 * @date 2015-4-7 下午2:56:36
 */ 
public class AutoRefreshUserCache extends AbstractTaskService {
	
	private static UcfLogger logger = UcfLoggerFactory.getLogger(AutoRefreshUserCache.class);
	
	@Autowired
	private UcfUserDao ucfUserDao;
	@Autowired
	private UcfCardDao ucfCardDao;
	
	@Autowired
	private UserService userService;
	
	@Resource(name="redisKVManager")
	private RedisKVManager cache = null;

	private int randomTimeout(int min,int max) {
		return new Random().nextInt(max * 86400)%(max * 86400-min * 86400+1) + min * 86400;
	}
	
	@Override
	public UcfScheduleResponse execute() {
		logger.info("刷新用户缓存数据定时任务执行开始!");
		UcfScheduleResponse response = new UcfScheduleResponse();
		ExecutorService ExecutorService =  Executors.newFixedThreadPool(20);
		try {
			UcfUser fuser = getFindUser(1);
			List<String> firseUserIds = userService.listPageUserId(fuser);
			int totalPage = fuser.getPage().getTotalPage();
			ExecutorService.submit(new FlushUser(firseUserIds));
			for(int p = 2;p<= totalPage;p++){
				UcfUser ruser = getFindUser(p);
				List<String> userIds = userService.listPageUserId(ruser);
				ExecutorService.submit(new FlushUser(userIds));
			}			
			response.setStatus(ScheduleStatusEnum.SUCCESS);
			logger.info("刷新用户缓存数据定时任务执行成功");
		} catch (Exception e) {
			response.setStatus(ScheduleStatusEnum.FAILED);
			logger.error("刷新用户缓存数据异常",e);
		}
		logger.info("刷新用户缓存数据定时任务执行结束!");
		return response;
	}

	private UcfUser getFindUser(int p){
		UcfUser user = new UcfUser();
		Page page = new Page();
		page.setCurrentPage(p);
		page.setShowCount(10000);
		user.setPage(page);
		return user;
	}
	
	class FlushUser implements Runnable {
		private List<String> userIds = null;
		public FlushUser(List<String> userIds){
			this.userIds = userIds;
		}
		public void run() {
			try {
				for(String  userId : userIds){			
					//查询用户的缓存keys
					String  userKey = EnumRedisKey.UCF_USER_QUERY_BY_USERId.getKey() + userId;
					if(cache.isExist(userKey)){
						ucfUserDao.refreshUserInfo(userId, randomTimeout(4,14));
						logger.info("刷新用户["+userId+"]UCF_USER缓存数据执行成功");
					}
					//查询card缓存keys
					String cardKey = EnumRedisKey.UCF_CARD_QUERY_BY_USERId.getKey() + userId;
					if(cache.isExist(cardKey)){
						ucfCardDao.refreshCardInfo(userId, randomTimeout(4,14));
						logger.info("刷新用户["+userId+"]UCF_CARD缓存数据执行成功");
					}
				}
			}catch (Exception e) {			
				logger.error("刷新用户缓存数据异常",e);
			}
		}
	}	
}
