package com.ucf.customer.p2p.controller;

import java.io.PrintWriter;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.validation.Valid;

import org.apache.cxf.common.util.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.ucf.customer.bo.ResultBo;
import com.ucf.customer.p2p.model.PasswordModel;
import com.ucf.customer.pojo.UcfBankCard;
import com.ucf.customer.pojo.UcfCard;
import com.ucf.customer.pojo.UcfUser;
import com.ucf.customer.security.Cryptos;
import com.ucf.customer.service.CardService;
import com.ucf.customer.service.HiddenService;
import com.ucf.customer.service.LoginService;
import com.ucf.customer.service.ProtectionSystemService;
import com.ucf.customer.service.UserInfoService;
import com.ucf.customer.service.UserService;
import com.ucf.customer.utils.Constants;
import com.ucf.customer.utils.enums.EnumResultCode;
import com.ucf.customer.utils.enums.EnumSessionKey;
import com.ucf.customer.utils.exception.P2PCustomerException;
import com.ucf.customer.ws.bo.SmsBO;
import com.ucf.customer.ws.bo.UserInfoBO;
import com.ucf.customer.ws.enums.EnumIdCardType;
import com.ucf.customer.ws.enums.Enumbase_platformCode;
import com.ucf.customer.ws.service.UserServiceWS;
import com.ucf.onlinepay.framework.common.util.StringUtil;
import com.ucf.platform.framework.core.log.UcfLogger;
import com.ucf.platform.framework.core.log.UcfLoggerFactory;
import com.ucf.platform.framework.core.util.SensitiveInfoUtils;
import com.ucf.platform.framework.redis.support.IAtomic;

@SuppressWarnings("unchecked")
@Controller
@RequestMapping("/p2p")
public class PasswordManageController {
	
	private static UcfLogger LOGGER = UcfLoggerFactory.getLogger(PasswordManageController.class);
	
	@Autowired
	private LoginService loginService;
	@Autowired
	private HiddenService hiddenServiceImpl;
	@Autowired
	private UserService userService;
	@Autowired
	private ProtectionSystemService protectionSystemService;
	@Autowired
	private UserServiceWS userServiceWS;
	@Resource
	private CardService cardServiceImpl;
	
	private static final String key = Constants.P2P_STRING + "_pwd";
	private static final String SESSION_REQUEST_INF_KEY = "P2P_RECHARGE_REQUEST_INF";
	//用户是否通过安全验证
	private static final String isUserPassSecure = "IS_USER_PASS_SECURE";
	
	@Autowired
	private IAtomic<String> atomic = null;
	
	@Autowired
	private UserInfoService userInfoService;
	
	@RequestMapping(value = "/toFindPayPwd")
	public String toFindPayPwd(@Valid PasswordModel pwd, BindingResult result,
			HttpServletRequest request, HttpServletResponse response, Model model) throws P2PCustomerException {
		String url="";
		try {
			LOGGER.info("找回支付密码接收到参数:"+SensitiveInfoUtils.getJson(pwd));
			String msg = pwd.valid(pwd);
			if (null != msg) {
				model.addAttribute("msg", msg);
				return "p2p/err";
			}
			UcfUser user = loginService.queryUserInfo(pwd.getUserId(),pwd.getMerchantId());
			List<UcfBankCard> ucfBankCards = userService.queryUserBankInfos(pwd.getMerchantId(), pwd.getUserId(),"S");
			
			//add by 李文静
			UserInfoBO userInfoBO= userServiceWS.getUsreInfoByUserId(pwd.getUserId());
			if (EnumIdCardType.GAT_NO.getCode().equals(userInfoBO.getUserCertType())) {
				model.addAttribute("msg", "港澳台用户不能找回密码功能");
				return "p2p/err";
			}
			// 数据过滤，状态为删除的过滤掉
			Iterator<UcfBankCard> sListIterator = ucfBankCards.iterator();
			//如果type为common则判断银行 预留手机号 发送验证码用 add by gaoxiang
			if("common".equalsIgnoreCase(pwd.getType())){
				while (sListIterator.hasNext()) {
					UcfBankCard e = sListIterator.next();
					//mod by cxd 2014-07-31 帮李文静修改 当手机号为空,同样不可修改支付密码
					if (StringUtil.isEmpty(e.getPhone())) {
						sListIterator.remove();
					}
				}
			//否则不判断预留手机号
			}else{
				while (sListIterator.hasNext()) {
					UcfBankCard e = sListIterator.next();
				}
			}
			HttpSession session = request.getSession();
			session.setAttribute(key, pwd);
			session.setAttribute("cellNo" + SESSION_REQUEST_INF_KEY + "_customer", user.getCell());
			session.setAttribute("user", user);
			//注入短信发送手机号
			session.setAttribute(EnumSessionKey.SMS_PHONE.getKey(), user.getCell());
			model.addAttribute("bankCard", ucfBankCards!=null&&ucfBankCards.size()>0?ucfBankCards.get(0):null);
			model.addAttribute("user", user);
			model.addAttribute("banks", ucfBankCards);
			model.addAttribute("merchantId", pwd.getMerchantId());
			model.addAttribute("backUrl", pwd.getBackUrl());
			//如果type=common则进入有卡找回密码页面，否则进入 无卡找回密码页面 addBy gaoxiang
			url="common".equalsIgnoreCase(pwd.getType())?"p2p/findPayPwd":ucfBankCards!=null&&ucfBankCards.size()>0?"p2p/findCardPayPwd":"p2p/findNoCardPayPwd";
		} catch (Exception e) {
			LOGGER.debug(e.getMessage(), e);
			request.setAttribute("msg", "操作失败");
			throw new P2PCustomerException();
		}
		return url;
	}

	@RequestMapping(value = "/toSetPayPwd")
	public String toSetPayPwd(@RequestParam("vfyCode") String vfyCode,
			@RequestParam("bankId") String bankId,
			@RequestParam("bankNo") String bankNo,
			@RequestParam("idNo") String idNo,
			@RequestParam("realName") String realName,
			@RequestParam("merchantId") String merchantId,
			@RequestParam("cellNo") String cellNo, HttpServletRequest request,
			HttpServletResponse response, Model model)
			throws P2PCustomerException {
		try {
			HttpSession session = request.getSession();
			PasswordModel pwd = (PasswordModel) session.getAttribute(key);
			if (!loginService.checkQusAndAsw(pwd.getUserId())) {
				model.addAttribute("msg", "用户被冻结，24小时内不可进行找回密码操作");
				return "p2p/err";
			}
			if (!checkmMbileCode(request, response, vfyCode, cellNo)) {
				model.addAttribute("msg", "短信验证码错误！");
				return "p2p/err";
			}
			if (userService.canFindPayPwd(bankId, pwd.getUserId(), realName, idNo, bankNo, cellNo)) {
				model.addAttribute("userId", pwd.getUserId());
				model.addAttribute("merchantId", merchantId);
				UcfUser user = loginService.queryUserInfo(pwd.getUserId(), pwd.getMerchantId());
				model.addAttribute("p2p_type", pwd.getType());
				model.addAttribute("HID_user", hiddenServiceImpl.hidden(user));
				//该用户是否通过安全验证 放入session
				session.setAttribute(isUserPassSecure+pwd.getUserId(), "pass");
				return "p2p/setPayPwd";
			} else {
				model.addAttribute("msg", "校验失败,请确认信息是否正确！");
				return "p2p/err";
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage(), e);
			request.setAttribute("msg", "操作失败");
			throw new P2PCustomerException();
		}
	}

	@RequestMapping(value = "/toSetPasswd")
	public String toSetPasswd(@RequestParam("cellNo") String cellNo,
			@RequestParam("realName") String realName,
			@RequestParam("certNo") String certNo,
			@RequestParam("vercode") String vercode,
			HttpServletRequest request, HttpServletResponse response, Model model) throws P2PCustomerException {
		try {
			HttpSession session = request.getSession();
			PasswordModel pwd = (PasswordModel) session.getAttribute(key);
			if (!loginService.checkQusAndAsw(pwd.getUserId())) {
				model.addAttribute("msg", "用户被冻结，24小时内不可进行找回密码操作");
				return "p2p/err";
			}
			if (!checkmMbileCode(request, response, vercode, cellNo)) {
				model.addAttribute("msg", "短信验证码错误！");
				return "p2p/err";
			}
			//如果是有卡找回支付密码  需要验证 银行卡号
			String bankId=request.getParameter("bankId");
			String bankCardNo=request.getParameter("bankCardNo");
			//核实 身份
			if (userService.verifyIdentity(bankId, pwd.getUserId(), realName, certNo, bankCardNo, cellNo)) {
				model.addAttribute("userId", pwd.getUserId());
				model.addAttribute("merchantId", pwd.getMerchantId());
				UcfUser user = loginService.queryUserInfo(pwd.getUserId(), pwd.getMerchantId());
				model.addAttribute("HID_user", hiddenServiceImpl.hidden(user));
				//该用户是否通过安全验证 放入session
				session.setAttribute(isUserPassSecure+pwd.getUserId(), "pass");
				return "p2p/set_passwd";
			}else{
				model.addAttribute("msg", "校验失败,请确认信息是否正确！");
				return "p2p/err";
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage(), e);
			request.setAttribute("msg", "操作失败");
			throw new P2PCustomerException();
		}
	}

	/**
	 * 校验短信验证码
	 * 
	 * @param request
	 * @param response
	 * @param vercodeInput
	 * @return
	 */
	private boolean checkmMbileCode(HttpServletRequest request, HttpServletResponse response, String vercodeInput, String mobileNo) {
		try {
			SmsBO smsBO = userServiceWS.checkSms("base_platform", mobileNo, vercodeInput);
			return smsBO.isCheckResult();
		} catch (Exception e) {
			LOGGER.error("调用会员短信校验接口错误");
			return false;
		}
	}
	
	@RequestMapping(value = "/setPayPwd")
	public String setPayPwd(HttpServletRequest request, HttpServletResponse response, Model model) throws P2PCustomerException {
		try {
			//判断该用户是否通过安全验证
			HttpSession session = request.getSession();
			UcfUser user = (UcfUser) session.getAttribute("user");
			Object isPass = session.getAttribute(isUserPassSecure+user.getUserId());
			if(isPass==null || !"pass".equals(isPass)){
				model.addAttribute("msg", "未通过安全验证，非法访问!");
				return "p2p/err";
			}
			//支付密码确认
			String payPassword=String.valueOf(request.getAttribute("payPassword"));
			String conPayPassword=String.valueOf(request.getAttribute("payPassword1"));
			PasswordModel pwd = (PasswordModel) session.getAttribute(key);
			model.addAttribute("backUrl", pwd.getBackUrl());
			//如果type是common
			if("common".equals(pwd.getType())){
				//判断密码
				boolean flag=checkPassword(payPassword);
				if(payPassword.length()<6 || payPassword.length()>20 || flag){
					LOGGER.info("密码不符合要求！");
					model.addAttribute("msg", "必须是6-20个英文字母、数字或符号，不能是纯数字 ！");
					return "p2p/err";
				}
			}else{
				//判断密码
				String regex = "^[0-9]+$";
				boolean flag=match(regex,payPassword);
				if(payPassword.length()!=6 || !flag){
					LOGGER.info("密码不符合要求,必须是6位数字！");
					model.addAttribute("msg", "必须是6位数字！");
					return "p2p/err";
				}
			}
			if(!payPassword.equals(conPayPassword)){
				LOGGER.info("支付密码和确认密码不相等！");
				model.addAttribute("msg", "支付密码和确认密码不相等！");
				return "p2p/err";
			}

			if (payPassword.equals(conPayPassword)) {
				try {
					UcfCard card = loginService.queryUcfCardByUserId(pwd.getUserId());
					card.setPaymentPassword(Cryptos.encrypt(payPassword,pwd.getUserId()));
					loginService.updateUcfCard(card);
					cardServiceImpl.freezeUcfCard(pwd.getUserId(), "0", null);
					if (atomic.isExist(pwd.getUserId())) {
						atomic.delete(pwd.getUserId());
					}
					String expireKey = "verifyPayPassword|"+pwd.getUserId();
					if (atomic.isExist(expireKey)) {
						atomic.delete(expireKey);
					}
//					notice(request, response);
					model.addAttribute("msg", "找回密码成功");
					return "p2p/success";
				} catch (Exception e) {
					LOGGER.error("查询账户失败", e);
					model.addAttribute("msg", "查询用户失败");
					return "p2p/err";
				}	
			}

			model.addAttribute("msg", "两次输入密码不一致");
			return "p2p/err";
		} catch (Exception e) {
			LOGGER.error(e.getMessage(), e);
			request.setAttribute("msg", "操作失败");
			throw new P2PCustomerException();
		}
	}
	
	@RequestMapping(value = "/setPasswd")
	public String setPasswd(HttpServletRequest request, HttpServletResponse response, Model model) throws P2PCustomerException {
		//判断该用户是否通过安全验证
		HttpSession session = request.getSession();
		UcfUser user = (UcfUser) session.getAttribute("user");
		Object isPass = session.getAttribute(isUserPassSecure+user.getUserId());
		if(isPass==null || !"pass".equals(isPass)){
			model.addAttribute("msg", "未通过安全验证，非法访问!");
			return "p2p/err";
		}
		
		String payPassword= request.getParameter("payPassword");
		String plainPassword = protectionSystemService.getPlainPassword(payPassword);
		String conPayPassword= request.getParameter("payPassword1");
		String plainConPayPassword = protectionSystemService.getPlainPassword(conPayPassword);
		//判断密码控件是否获取到密码
		if(StringUtils.isEmpty(plainPassword) || StringUtils.isEmpty(plainConPayPassword)){
			LOGGER.error("密码控件异常，未获取到密码！");
			model.addAttribute("msg", "支付密码解析错误 ！");
			return "p2p/err";
		}
		try {
			PasswordModel pwd = (PasswordModel) session.getAttribute(key);
			model.addAttribute("backUrl", pwd.getBackUrl());
			if (plainPassword.equals(plainConPayPassword)) {
				try {
					UcfCard card = loginService.queryUcfCardByUserId(pwd.getUserId());
					card.setPaymentPassword(Cryptos.encrypt(plainPassword,pwd.getUserId()));
					loginService.updateUcfCard(card);
					cardServiceImpl.freezeUcfCard(pwd.getUserId(), "0", null);
					if (atomic.isExist(pwd.getUserId())) {
						atomic.delete(pwd.getUserId());
					}
					String expireKey = "verifyPayPassword|"+pwd.getUserId();
					if (atomic.isExist(expireKey)) {
						atomic.delete(expireKey);
					}			
					model.addAttribute("msg", "找回密码成功");
					return "p2p/findpaypwd_success";
				} catch (Exception e) {
					LOGGER.error("查询账户失败", e);
					model.addAttribute("msg", "查询用户失败");
					return "p2p/err";
				}
			}
			model.addAttribute("msg", "两次输入密码不一致");
			return "p2p/err";
		} catch (Exception e) {
			LOGGER.error(e.getMessage(), e);
			request.setAttribute("msg", "操作失败");
			throw new P2PCustomerException();
		}
	}
	
	@RequestMapping(value = "/findPayPwd")
	public String findPayPwd(HttpServletRequest request, HttpServletResponse response) throws P2PCustomerException {
		try {
			JSONObject jsonObj = new JSONObject();
			jsonObj.putAll(request.getParameterMap());
			LOGGER.info(" 接收到参数:"+jsonObj.toString());
			return "p2p/success";
		} catch (Exception e) {
			LOGGER.error(e.getMessage(), e);
			request.setAttribute("msg", "操作失败");
			throw new P2PCustomerException();
		}
	}
	
	@RequestMapping(value = "/toModifyPayPwd")
	public String toModifyPayPwd(@Valid PasswordModel pwd, BindingResult result, HttpServletRequest request,
			HttpServletResponse response, Model model) throws P2PCustomerException {
		try {
			LOGGER.info("修改密码接收到参数:"+JSON.toJSONString(pwd));
			model.addAttribute("backUrl", pwd.getBackUrl());
			HttpSession session = request.getSession();
			session.setAttribute(key, pwd);
			String msg = pwd.valid(pwd);
			if (null != msg) {
				LOGGER.debug("<---传入参数校验错误--->");
				model.addAttribute("msg", msg);
				return "p2p/err";
			}
			try {
				UcfUser user = loginService.queryUserInfo(pwd.getUserId(), pwd.getMerchantId());
				//add by 李文静
				UserInfoBO userInfoBO= userServiceWS.getUsreInfoByUserId(pwd.getUserId());
				if (EnumIdCardType.GAT_NO.getCode().equals(userInfoBO.getUserCertType())) {
					model.addAttribute("msg", "港澳台用户不能修改密码功能");
					return "p2p/err";
				}
				session.setAttribute("user", user);
				//注入短信发送手机号
				session.setAttribute(EnumSessionKey.SMS_PHONE.getKey(), user.getCell());
				model.addAttribute("p2p_type", pwd.getType());
				model.addAttribute("cellNo", user.getCell());
				model.addAttribute("HID_user", hiddenServiceImpl.hidden(user));
				model.addAttribute("merchantId", pwd.getMerchantId());
				return "p2p/modifyPayPwd";
			} catch (Exception e) {
				LOGGER.error("查询用户失败", e);
				model.addAttribute("msg", "查询用户失败");
				return "p2p/err";
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage(), e);
			request.setAttribute("msg", "操作失败");
			throw new P2PCustomerException();
		}
	}
	
	@RequestMapping(value = "/toReturnModifyPayPwd")
	public String toReturnModifyPayPwd(HttpServletRequest request, HttpServletResponse response, Model model) throws P2PCustomerException {
		try {
			LOGGER.info(" [原request]接收到参数:"+ JSON.toJSONString(request.getParameterMap()));
			HttpSession session = request.getSession();
			PasswordModel pwd = (PasswordModel) session.getAttribute(key);
			model.addAttribute("backUrl", pwd.getBackUrl());
			String msg = pwd.valid(pwd);
			if (null != msg) {
				LOGGER.debug("<---传入参数校验错误--->");
				model.addAttribute("msg", msg);
				return "p2p/err";
			}
			try {
				UcfUser user = loginService.queryUserInfo(pwd.getUserId(), pwd.getMerchantId());
				session.setAttribute("user", user);
				model.addAttribute("cellNo", user.getCell());
				model.addAttribute("HID_user", hiddenServiceImpl.hidden(user));
				model.addAttribute("merchantId", pwd.getMerchantId());
				model.addAttribute("p2p_type", pwd.getType());
				return "p2p/modifyPayPwd";
			} catch (Exception e) {
				LOGGER.error("查询用户失败", e);
				model.addAttribute("msg", "查询用户失败");
				return "p2p/err";
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage(), e);
			request.setAttribute("msg", "操作失败");
			throw new P2PCustomerException();
		}
	}
	
	@RequestMapping(value = "/modifyPayPwd")
	public String modifyPayPwd(@RequestParam("vfyCode") String vfyCode, HttpServletRequest request, HttpServletResponse response,
			Model model) throws P2PCustomerException {
		try {
			//支付密码确认
			String oldPassword=String.valueOf(request.getAttribute("payPassword"));
			String newPassword=request.getParameter("newPassword");
			String conPayPassword=request.getParameter("conPayPassword");
			HttpSession session = request.getSession();
			PasswordModel pwd = (PasswordModel) session.getAttribute(key);
			model.addAttribute("backUrl", pwd.getBackUrl());
			ResultBo resultBo = userInfoService.checkPayPwd(pwd.getUserId(), oldPassword.getBytes());
			if(!EnumResultCode.SUCCESS.getCode().equals(resultBo.getResult())){
				model.addAttribute("msg", resultBo.getMsg());
				return "p2p/err";
			}
			String returnUrl = "p2p/toReturnModifyPayPwd?userId=" + pwd.getUserId() + "&merchantId=" + pwd.getMerchantId();
			if(oldPassword.equals(newPassword)){
				model.addAttribute("msg", "新密码不可与原密码一致");
				model.addAttribute("backUrl",returnUrl);
				return "p2p/err";
			}
			String actCode = (String) session.getAttribute("vfyCode");
			session.removeAttribute("vfyCode");
			if (null != vfyCode && !"".equals(vfyCode) && vfyCode.equals(actCode)) {
				//如果type是common
				if("common".equals(pwd.getType())){
					//判断密码
					boolean flag=checkPassword(newPassword);
					if(newPassword.length()<6 || newPassword.length()>20 || flag){
						LOGGER.info("密码不符合要求！");
						model.addAttribute("msg", "必须是6-20个英文字母、数字或符号，不能是纯数字 ！");
						return "p2p/err";
					}
				}else{
					//判断密码
					boolean flag=match("^[0-9]+$",newPassword);
					if(newPassword.length()!=6 || !flag){
						LOGGER.info("密码不符合要求,必须是6位数字！");
						model.addAttribute("msg", "必须是6位数字！");
						return "p2p/err";
					}
				}
				if(!newPassword.equals(conPayPassword)){
					LOGGER.info("支付密码和确认密码不相等！");
					model.addAttribute("msg", "支付密码和确认密码不相等！");
					return "p2p/err";
				}				
				try {
					if (newPassword.equals(conPayPassword)) {
							UcfCard card = loginService.queryUcfCardByUserId(pwd.getUserId());
							card.setPaymentPassword(Cryptos.encrypt(newPassword,pwd.getUserId()));
							loginService.updateUcfCard(card);
							model.addAttribute("msg", "修改支付密码成功");
							return "p2p/success";
					}else{
						model.addAttribute("msg", "两次新密码不一致");
						model.addAttribute("backUrl",returnUrl);
						return "p2p/err";
					}
				} catch (Exception e) {
					LOGGER.error("修改支付密码失败", e);
					model.addAttribute("msg", "修改支付密码失败");
					model.addAttribute("backUrl",returnUrl);
					return "p2p/err";
				}
			}
			model.addAttribute("msg", "验证码错误");
			model.addAttribute("backUrl",returnUrl);
			return "p2p/err";
		} catch (Exception e) {
			LOGGER.error(e.getMessage(), e);
			request.setAttribute("msg", "操作失败");
			throw new P2PCustomerException();
		}
	}
	
	/**
	 * 
	 * Description: 发送手机验证码
	 * @Version1.0 2014-3-18 下午3:40:52 by 李晓明（lixiaoming@ucfgroup.com）创建
	 * @param cellNo
	 * @throws Exception 
	 */
	@RequestMapping({ "/sendSms.htm" })
	public void sendSmsNew(
			@RequestParam(value = "smsType") String smsType,
			@RequestParam(value = "cellNo") String cellNo,
			HttpServletRequest request, HttpServletResponse response,Model model,PrintWriter printWriter){
		final HttpSession session = request.getSession();
		UcfUser user = (UcfUser)session.getAttribute("user");
		if(user==null){
			printWriter.write(JSONObject.toJSONString("用户未登录"));
			printWriter.flush();
			printWriter.close();
			return;
		}
		try {
			String redisUserKey = "base_platform_P2P_FIND_PAY_PWD_SMS_USER_TIME_" + user.getUserId();
			String redisPhoneKey = "base_platform_P2P_FIND_PAY_PWD_SMS_PHONE_TIME_" + user.getUserId();
			int utimes = 0;
			int ptimes = 0;
			if (atomic.isExist(redisUserKey)) {
				utimes = atomic.getLong(redisUserKey).intValue();
			}
			if (atomic.isExist(redisPhoneKey)) {
				ptimes = atomic.getLong(redisPhoneKey).intValue();
			}
			if (utimes > 9 || ptimes > 9) {
				printWriter.write(JSONObject.toJSONString("验证码发送过于频繁，三小时后再试！"));
				printWriter.flush();
				printWriter.close();
				return;
			}else{
				SmsBO vfyCode = userServiceWS.sendSms("base_platform", cellNo);
				if (!vfyCode.getRespCode().equals(Enumbase_platformCode.SUCCESS.getCode())) {
					printWriter.write(vfyCode.getRespMsg());
				} else {
					session.setAttribute("vfyCode|"+cellNo, vfyCode.getCode());
					if(utimes == 0){
						atomic.set(redisUserKey, 1, 60 * 60 * 3, TimeUnit.SECONDS);
						atomic.set(redisPhoneKey, 1, 60 * 60 * 3, TimeUnit.SECONDS);
					}else{
						atomic.incrementAndGet(redisUserKey, 1);
						atomic.incrementAndGet(redisPhoneKey, 1);
					}
					LOGGER.info("发送的短信,手机号：" + cellNo + "|短信vfyCode：" + vfyCode.getCode());
					printWriter.write(JSONObject.toJSONString("验证码已发送"));
				}
			}				
		} catch (Exception e) {
			LOGGER.error(e.getMessage(), e);
			LOGGER.error("调用会员发送短信接口失败");
			printWriter.write(JSONObject.toJSONString("验证码发送失败"));
		}
		printWriter.flush();
		printWriter.close();
	}
	
	public static boolean checkPassword(String str) {
		String regex1 = "^[A-Za-z]+$";
		String regex2 = "^[0-9]+$";
		return match(regex1, str) || match(regex2, str);
	}
	
	private static boolean match(String regex, String str) {
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(str);
		return matcher.matches();
	}

}