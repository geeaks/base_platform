
package com.ucf.customer.security;

import java.security.GeneralSecurityException;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;


/**
 * 支持HMAC-SHA1消息签名 及 DES/AES对称加密的工具类.
 * 
 * 支持Hex与Base64两种编码方式.
 * 
 * @author calvin
 */
public class Cryptos {

	private static final String HMACSHA1 = "HmacSHA1";

	private static final String AES = "AES";
	
	private static final byte [] AES_KEY = {-88, 1, -21, -47, -83, 44, -31, 14, -44, -116, 111, 106, -83, -90, -81, 2};
	
	// -- HMAC-SHA1 funciton --//
	/**
	 * 使用HMAC-SHA1进行消息签名, 返回字节数组,长度为20字节.
	 * 
	 * @param input 原始输入字符数组
	 * @param key HMAC-SHA1密钥
	 */
	private static byte[] hmacSha1(byte[] input, byte[] key) {
		try {
			SecretKey secretKey = new SecretKeySpec(key, HMACSHA1);
			Mac mac = Mac.getInstance(HMACSHA1);
			mac.init(secretKey);
			return mac.doFinal(input);
		} catch (GeneralSecurityException e) {
			throw new RuntimeException (e);
		}
	}

	/**
	 * 校验HMAC-SHA1签名是否正确.
	 * 
	 * @param expected 已存在的签名
	 * @param input 原始输入字符串
	 * @param key 密钥
	 */
	private static boolean isMacValid(byte[] expected, byte[] input, byte[] key) {
		byte[] actual = hmacSha1(input, key);
		return Arrays.equals(expected, actual);
	}

	/**
	 * 使用AES加密原始字符串.
	 * 
	 * @param input 原始输入字符数组
	 * @param key 符合AES要求的密钥
	 */
	public static String aesEncrypt(String input) {
		byte[] encryptResult = aes(input.getBytes(), AES_KEY, Cipher.ENCRYPT_MODE);
		String encodeHex = Cryptos.encodeHex(encryptResult);
		return encodeHex;
	}

	/**
	 * 使用AES解密字符串, 返回原始字符串.
	 * @param input Hex编码的加密字符串
	 * @param key 符合AES要求的密钥
	 */
	public static String aesDecrypt(String input) {
		byte[] decodeHex = decodeHex(input);
		byte[] decryptResult = aes(decodeHex, AES_KEY, Cipher.DECRYPT_MODE);
		return new String(decryptResult);
	}
	
	/**
	 * 使用AES加密或解密无编码的原始字节数组, 返回无编码的字节数组结果.
	 * 
	 * @param input 原始字节数组
	 * @param key 符合AES要求的密钥
	 * @param mode Cipher.ENCRYPT_MODE 或 Cipher.DECRYPT_MODE
	 */
	private static byte[] aes(byte[] input, byte[] key, int mode) {
		try {
			SecretKey secretKey = new SecretKeySpec(key, AES);
			Cipher cipher = Cipher.getInstance(AES);
			cipher.init(mode, secretKey);
			return cipher.doFinal(input);
		} catch (GeneralSecurityException e) {
			throw new RuntimeException (e);
		}
	}
	
	/**
	 * Hex编码.
	 */
	private static String encodeHex(byte[] input) {
		return Hex.encodeHexString(input);
	}

	/**
	 * Hex解码.
	 */
	private static byte[] decodeHex(String input) {
		try {
			return Hex.decodeHex(input.toCharArray());
		} catch (DecoderException e) {
			throw new RuntimeException (e);
		}
	}
	/**
	 * SHA1加密
	 * @author yuzengjia
	 * @date 2014-6-7 下午4:13:13
	 * @param inputStr 待加密串
	 * @param key
	 * @return
	 */
	public static String encrypt(String inputStr,String key){
		byte[] macResult = Cryptos.hmacSha1(inputStr.getBytes(), key.getBytes());
		return encodeHex(macResult);
	}
	/**
	 * 验证原串与加密后的串是否一致
	 * @author yuzengjia
	 * @date 2014-6-7 下午4:13:45
	 * @param res 加密后的串，即库中的值
	 * @param inputStr 输入串
	 * @param key
	 * @return
	 */
	public static boolean validate(String res,String inputStr,String key){
		return Cryptos.isMacValid(decodeHex(res), inputStr.getBytes(), key.getBytes());
	}
	
	public static boolean isUserPwdMatch(String userId, String pwd1,String pwd2){
		if(pwd1.equals(pwd2)){
			return true;
		}
		String pwdSec1 = Cryptos.encrypt(pwd1, userId);
		String pwdSec2 = Cryptos.encrypt(pwd2, userId);
		if(pwdSec1.equals(pwdSec2) || pwdSec1.equals(pwd2) || pwd1.equals(pwdSec2)){
			return true;
		}
		return false;
	}
	
	public static void main(String [] args){
		System.out.println(encrypt("123xxx","10000003476"));
		System.out.println(isUserPwdMatch("10000003476","123xxx","effb8b5af5e99049fa54b1ec7b642d7957881b52"));
	}
	
}